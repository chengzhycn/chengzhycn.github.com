<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Courses on Terminal</title>
    <link>https://chengzhycn.github.io/categories/courses/</link>
    <description>Recent content in Courses on Terminal</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 27 Aug 2025 12:58:54 +0800</lastBuildDate>
    <atom:link href="https://chengzhycn.github.io/categories/courses/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>KAIST-CS431: Lock Based API</title>
      <link>https://chengzhycn.github.io/posts/2025-08/kaist-cs431-lock-based-api/</link>
      <pubDate>Wed, 27 Aug 2025 12:58:54 +0800</pubDate>
      <guid>https://chengzhycn.github.io/posts/2025-08/kaist-cs431-lock-based-api/</guid>
      <description>&lt;h2 id=&#34;标准库中的并发api&#34;&gt;标准库中的并发API&lt;/h2&gt;&#xA;&lt;p&gt;Rust 标准库中基于锁的 API 主要围绕几个核心原语构建，这些原语提供了不同级别的并发控制和用途。它们都包含在 &lt;code&gt;std::sync&lt;/code&gt; 模块中。以下是一些最常用的基于锁的 API：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;std::sync::Mutex&amp;lt;T&amp;gt;&lt;/code&gt; (互斥锁)&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 最常见的互斥锁，用于保护共享数据，确保一次只有一个线程可以访问该数据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当线程尝试获取已被锁定的 Mutex 时，它会阻塞直到锁被释放。&lt;/li&gt;&#xA;&lt;li&gt;提供内部可变性（&lt;code&gt;&amp;amp;T&lt;/code&gt; -&amp;gt; &lt;code&gt;&amp;amp;mut T&lt;/code&gt;）通过 RAII (Resource Acquisition Is Initialization) 机制，即 &lt;code&gt;MutexGuard&lt;/code&gt;。当 &lt;code&gt;MutexGuard&lt;/code&gt; 离开作用域时，锁会自动释放。&lt;/li&gt;&#xA;&lt;li&gt;是“poisoning”感知的：如果持有锁的线程在锁被释放前发生 panic，&lt;code&gt;Mutex&lt;/code&gt; 会被标记为 poisoned。后续尝试获取锁的线程会得到一个 &lt;code&gt;PoisonError&lt;/code&gt;，其中包含原始的 &lt;code&gt;MutexGuard&lt;/code&gt;，允许它们决定如何处理被中断的数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;何时使用：&lt;/strong&gt; 当你需要独占访问某个共享资源时，例如全局计数器、数据结构或配置设置。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;std::sync::RwLock&amp;lt;T&amp;gt;&lt;/code&gt; (读写锁)&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 允许多个读取者同时访问共享数据，但只允许一个写入者独占访问数据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;读取者（&lt;code&gt;read()&lt;/code&gt;）：&lt;/strong&gt; 允许多个线程并行获取读锁。只要没有写入者持有锁，所有读锁请求都会成功。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;写入者（&lt;code&gt;write()&lt;/code&gt;）：&lt;/strong&gt; 只允许一个线程获取写锁。当有写入者持有锁时，所有读锁和写锁请求都会阻塞。&lt;/li&gt;&#xA;&lt;li&gt;也提供 RAII 机制，通过 &lt;code&gt;RwLockReadGuard&lt;/code&gt; 和 &lt;code&gt;RwLockWriteGuard&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;同样是“poisoning”感知的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;何时使用：&lt;/strong&gt; 当你的数据被频繁读取但很少写入时，&lt;code&gt;RwLock&lt;/code&gt; 可以提供比 &lt;code&gt;Mutex&lt;/code&gt; 更好的并发性能。例如，一个缓存系统或一个配置对象。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;std::sync::Once&lt;/code&gt; (只运行一次)&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 确保某个代码块（一个初始化函数）在程序生命周期中只被执行一次，即使有多个线程同时尝试触发它。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;call_once()&lt;/code&gt; 方法会执行一个闭包。第一次调用会实际执行闭包，后续的调用会等待第一次调用完成，但不会再次执行闭包。&lt;/li&gt;&#xA;&lt;li&gt;通常用于惰性初始化全局数据或单例模式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;何时使用：&lt;/strong&gt; 初始化全局静态变量（例如日志系统、配置加载器）或实现单例模式。通常与 &lt;code&gt;lazy_static&lt;/code&gt; crate (在稳定版 Rust 中) 或 &lt;code&gt;std::sync::OnceLock&lt;/code&gt; (在 1.70+ 版本中，见下文) 结合使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;std::sync::Barrier&lt;/code&gt; (屏障)&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 用于同步一组线程，确保所有线程都到达某个预定义点后才能继续执行。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过 &lt;code&gt;wait()&lt;/code&gt; 方法实现等待。当调用 &lt;code&gt;wait()&lt;/code&gt; 的线程数量达到预设值时，所有等待的线程都会同时被释放。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt; 返回一个 &lt;code&gt;BarrierWaitResult&lt;/code&gt;，指示当前线程是否是最后一个到达屏障的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;何时使用：&lt;/strong&gt; 需要协调多个并行任务的执行，例如在某个阶段结束后开始下一阶段，或者在所有子任务完成后进行汇总。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;Rust 1.70+ 中引入的更现代的基于锁的 API：&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>KAIST-CS431: Lock</title>
      <link>https://chengzhycn.github.io/posts/2022-03/kaist-cs431-lock/</link>
      <pubDate>Tue, 08 Mar 2022 00:00:00 +0000</pubDate>
      <guid>https://chengzhycn.github.io/posts/2022-03/kaist-cs431-lock/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Pros &amp;amp; cons:&lt;/strong&gt; simple &amp;amp; possibly inefficient&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;low-level-lock-api&#34;&gt;Low-Level Lock API&lt;/h2&gt;&#xA;&lt;p&gt;常用的low-level锁的API有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Lock.acquire()&lt;/strong&gt;: 阻塞，直到获取到锁&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Lock.try_acquire():&lt;/strong&gt; 返回锁是否已经被占用了，如果是，返回false，否，占用锁并返回true。不阻塞&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Lock.release()&lt;/strong&gt;: 释放锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;acquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;acquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;r2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是，这些API给用户在使用时造成了很多挑战（心智负担）：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Relating lock and resource&lt;/strong&gt;: 用户只有在拿到锁时才能访问被保护的变量；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Matching acquire/release&lt;/strong&gt;: 用户只能释放已经拿到的锁。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果锁没有得到正确的处理，会造成很多潜在的问题，并且，这些问题很难发现。因此，在并发编程时，low-level的锁API存在如下问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;High cost&lt;/strong&gt;：程序员需要始终关注API的使用；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Potential bugs&lt;/strong&gt;：不正确的使用容易造成很多潜在的bugs。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;high-level-lock-api&#34;&gt;High-Level Lock API&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;想要一个易用地，始终能保证安全地high-level API。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Acquire/release自动匹配；&lt;/li&gt;&#xA;&lt;li&gt;Lock和resource显式关联。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;C++中，这种API被称作&lt;strong&gt;RAII&lt;/strong&gt;：&lt;strong&gt;Resource Acquisition Is Initialization&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;mutex&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;fstream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdexcept&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;write_to_file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 创建关于文件的互斥锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 在访问文件前进行加锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock_guard&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 尝试打开文件&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ofstream&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;example.txt&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;runtime_error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;unable to open file&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 输出文件内容&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 当离开作用域时，文件句柄会被首先析构 (不管是否抛出了异常)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 互斥锁也会被析构 (同样地，不管是否抛出了异常)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;RAII要求，资源的有效期与持有资源的&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%e5%af%b9%e8%b1%a1%e7%9a%84%e7%94%9f%e5%91%bd%e6%9c%9f&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;对象的生命期&lt;/a&gt;严格绑定，即由对象的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&#34;&gt;构造函数&lt;/a&gt;完成&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%e8%b5%84%e6%ba%90%e7%9a%84%e5%88%86%e9%85%8d&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;资源的分配&lt;/a&gt;（获取），同时由&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&#34;&gt;析构函数&lt;/a&gt;完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%e8%b5%84%e6%ba%90%e6%b3%84%e9%9c%b2&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;资源泄露&lt;/a&gt;问题。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
