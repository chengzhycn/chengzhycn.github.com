<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Work on chengzhycn&#39;s blog</title>
    <link>https://chengzhycn.github.io/categories/work/</link>
    <description>Recent content in Work on chengzhycn&#39;s blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 26 Aug 2025 12:29:03 +0800</lastBuildDate>
    <atom:link href="https://chengzhycn.github.io/categories/work/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Wasm Internals - Overview</title>
      <link>https://chengzhycn.github.io/posts/2025-08/wasm-internals-overview/</link>
      <pubDate>Tue, 26 Aug 2025 12:29:03 +0800</pubDate>
      <guid>https://chengzhycn.github.io/posts/2025-08/wasm-internals-overview/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://rsms.me/wasm-intro&#34;&gt;https://rsms.me/wasm-intro&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/&#34;&gt;https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;wasm-的历史发展&#34;&gt;Wasm 的历史发展&lt;/h2&gt;&#xA;&lt;h3 id=&#34;早期wasm-mvp---2017&#34;&gt;早期（Wasm MVP - 2017）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;诞生背景：&lt;/strong&gt; Wasm 的设计目标是为了替代 asm.js，提供更小、更快、更安全的 Web 二进制格式。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;核心模块的初步定义：&lt;/strong&gt; MVP（Minimum Viable Product）阶段定义了 Wasm Core Module 的基本结构：函数、内存、表、导入、导出、全局变量等。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;主要用例：&lt;/strong&gt; 游戏引擎、音视频编解码、计算密集型任务等。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;限制：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;没有模块化系统：&lt;/strong&gt; 模块之间没有标准的链接机制，只能通过宿主环境（如 JavaScript）进行协调。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;缺乏垃圾回收（GC）：&lt;/strong&gt; 需要手动内存管理或使用语言自带的 GC 机制（如 Emscripten 的 mimalloc）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;没有线程：&lt;/strong&gt; 无法直接利用多核 CPU。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;没有宿主 API 标准化：&lt;/strong&gt; 模块与宿主环境的交互方式高度依赖宿主（如浏览器），没有统一的接口定义。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;没有组件模型：&lt;/strong&gt; 模块重用和组合非常困难。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;中期mvp-之后---持续演进&#34;&gt;中期（MVP 之后 - 持续演进）&lt;/h3&gt;&#xA;&lt;p&gt;Wasm 社区和工作组认识到 MVP 的局限性，并开始着手扩展 Wasm 的能力，这直接影响了 Core Module 的能力：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;多值（Multiple Returns &amp;amp; Parameters）：&lt;/strong&gt; 允许函数返回多个值，接收多个参数，提高表达能力。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;引用类型（Reference Types）：&lt;/strong&gt; 引入了 &lt;code&gt;externref&lt;/code&gt; 和 &lt;code&gt;funcref&lt;/code&gt;，允许 Wasm 直接引用宿主对象和函数，而无需通过数字 ID 传递，为未来的 GC 和组件模型打下基础。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;固定大小的 SIMD（Fixed-width SIMD）：&lt;/strong&gt; 引入了新的指令集，允许在 Wasm 中进行向量化操作，进一步提升某些计算密集型任务的性能。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;线程（Threads）：&lt;/strong&gt; 引入了共享内存和原子操作，允许 Wasm 模块在多线程环境下运行，极大地提升了并行计算能力。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;内存增长和限制（Memory Growth and Limits）：&lt;/strong&gt; 提供了更灵活的内存管理机制。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Tail Calls（尾调用）：&lt;/strong&gt; 优化了函数调用的性能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;近期和未来wasm-component-model&#34;&gt;近期和未来（Wasm Component Model）&lt;/h3&gt;&#xA;&lt;p&gt;这是 Wasm 发展中最重要的方向之一，旨在解决 Core Module 在模块化和互操作性方面的根本性问题：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dns Zone Files</title>
      <link>https://chengzhycn.github.io/posts/2021-01/dns-zone-files/</link>
      <pubDate>Sun, 03 Jan 2021 10:18:55 +0800</pubDate>
      <guid>https://chengzhycn.github.io/posts/2021-01/dns-zone-files/</guid>
      <description>&lt;h2 id=&#34;cname-记录&#34;&gt;CNAME 记录&lt;/h2&gt;&#xA;&lt;h3 id=&#34;记录格式&#34;&gt;记录格式&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bar.example.com.&#x9;CNAME&#x9;foo.example.com.&#xA;foo.example.com.&#x9;A&#x9;&#x9;192.168.0.1&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;cname-记录的限制&#34;&gt;CNAME 记录的限制&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果一个 domain name 有了一个 CNAME 记录，那么它不能再拥有其它类型的记录&lt;/li&gt;&#xA;&lt;li&gt;CNAME 记录必须指向另外一个 domain name，而不是一个 IP&lt;/li&gt;&#xA;&lt;li&gt;CNAME 记录最好不要指向另外一个 CNAME 记录&lt;/li&gt;&#xA;&lt;li&gt;MX 和 NS 记录不能指向一个 CNAME 记录&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;srv-记录&#34;&gt;SRV 记录&lt;/h2&gt;&#xA;&lt;p&gt;type code：33&lt;/p&gt;&#xA;&lt;h3 id=&#34;记录格式-1&#34;&gt;记录格式&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;_service._protocol.name. TTL class SRV priority weight port target.&#xA;&#xA;_sip._tcp.example.com. 86400 IN SRV 0 5 5060 sipserver.example.com.&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;_service: 服务名称 symbolic name&lt;/li&gt;&#xA;&lt;li&gt;protocol: 协议&lt;/li&gt;&#xA;&lt;li&gt;name: domain name，以 . 结束&lt;/li&gt;&#xA;&lt;li&gt;priority: 条目优先级, 值越低优先级越高&lt;/li&gt;&#xA;&lt;li&gt;weight: 同样优先级内不同条目的权重&lt;/li&gt;&#xA;&lt;li&gt;target: canonical hostname，以 . 结束&#xA;如果是一个 MX 记录，那么 target 需要是一个 IP 地址（A 或者 AAAA）而不是 CNAME&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;soa-记录&#34;&gt;SOA 记录&lt;/h2&gt;&#xA;&lt;p&gt;start of authority, 一个权威的起始&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
