<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>KAIST-CS431: Lock Based API :: chengzhycn&#39;s blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="标准库中的并发API Rust 标准库中基于锁的 API 主要围绕几个核心原语构建，这些原语提供了不同级别的并发控制和用途。它们都包含在 std::sync 模块中。以下是一些最常用的基于锁的 API：
std::sync::Mutex&lt;T&gt; (互斥锁) 用途： 最常见的互斥锁，用于保护共享数据，确保一次只有一个线程可以访问该数据。 特点： 当线程尝试获取已被锁定的 Mutex 时，它会阻塞直到锁被释放。 提供内部可变性（&amp;T -&gt; &amp;mut T）通过 RAII (Resource Acquisition Is Initialization) 机制，即 MutexGuard。当 MutexGuard 离开作用域时，锁会自动释放。 是“poisoning”感知的：如果持有锁的线程在锁被释放前发生 panic，Mutex 会被标记为 poisoned。后续尝试获取锁的线程会得到一个 PoisonError，其中包含原始的 MutexGuard，允许它们决定如何处理被中断的数据。 何时使用： 当你需要独占访问某个共享资源时，例如全局计数器、数据结构或配置设置。 std::sync::RwLock&lt;T&gt; (读写锁) 用途： 允许多个读取者同时访问共享数据，但只允许一个写入者独占访问数据。 特点： 读取者（read()）： 允许多个线程并行获取读锁。只要没有写入者持有锁，所有读锁请求都会成功。 写入者（write()）： 只允许一个线程获取写锁。当有写入者持有锁时，所有读锁和写锁请求都会阻塞。 也提供 RAII 机制，通过 RwLockReadGuard 和 RwLockWriteGuard。 同样是“poisoning”感知的。 何时使用： 当你的数据被频繁读取但很少写入时，RwLock 可以提供比 Mutex 更好的并发性能。例如，一个缓存系统或一个配置对象。 std::sync::Once (只运行一次) 用途： 确保某个代码块（一个初始化函数）在程序生命周期中只被执行一次，即使有多个线程同时尝试触发它。 特点： call_once() 方法会执行一个闭包。第一次调用会实际执行闭包，后续的调用会等待第一次调用完成，但不会再次执行闭包。 通常用于惰性初始化全局数据或单例模式。 何时使用： 初始化全局静态变量（例如日志系统、配置加载器）或实现单例模式。通常与 lazy_static crate (在稳定版 Rust 中) 或 std::sync::OnceLock (在 1.70&#43; 版本中，见下文) 结合使用。 std::sync::Barrier (屏障) 用途： 用于同步一组线程，确保所有线程都到达某个预定义点后才能继续执行。 特点： 通过 wait() 方法实现等待。当调用 wait() 的线程数量达到预设值时，所有等待的线程都会同时被释放。 wait() 返回一个 BarrierWaitResult，指示当前线程是否是最后一个到达屏障的。 何时使用： 需要协调多个并行任务的执行，例如在某个阶段结束后开始下一阶段，或者在所有子任务完成后进行汇总。 Rust 1.70&#43; 中引入的更现代的基于锁的 API：
" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://chengzhycn.github.io/posts/2025-08/kaist-cs431-lock-based-api/" />





  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/fonts.min.176c65cdf7082e9866e90b1fa123c60056f6d985b7cd3c4235600dada719e971.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/main.min.0909aaaf12e6fc3cdf2758321db2805239dc85602baff9dc07ce57d3d7365095.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="https://chengzhycn.github.io/favicon.png">
<link rel="apple-touch-icon" href="https://chengzhycn.github.io/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="KAIST-CS431: Lock Based API">
<meta property="og:description" content="标准库中的并发API Rust 标准库中基于锁的 API 主要围绕几个核心原语构建，这些原语提供了不同级别的并发控制和用途。它们都包含在 std::sync 模块中。以下是一些最常用的基于锁的 API：
std::sync::Mutex&lt;T&gt; (互斥锁) 用途： 最常见的互斥锁，用于保护共享数据，确保一次只有一个线程可以访问该数据。 特点： 当线程尝试获取已被锁定的 Mutex 时，它会阻塞直到锁被释放。 提供内部可变性（&amp;T -&gt; &amp;mut T）通过 RAII (Resource Acquisition Is Initialization) 机制，即 MutexGuard。当 MutexGuard 离开作用域时，锁会自动释放。 是“poisoning”感知的：如果持有锁的线程在锁被释放前发生 panic，Mutex 会被标记为 poisoned。后续尝试获取锁的线程会得到一个 PoisonError，其中包含原始的 MutexGuard，允许它们决定如何处理被中断的数据。 何时使用： 当你需要独占访问某个共享资源时，例如全局计数器、数据结构或配置设置。 std::sync::RwLock&lt;T&gt; (读写锁) 用途： 允许多个读取者同时访问共享数据，但只允许一个写入者独占访问数据。 特点： 读取者（read()）： 允许多个线程并行获取读锁。只要没有写入者持有锁，所有读锁请求都会成功。 写入者（write()）： 只允许一个线程获取写锁。当有写入者持有锁时，所有读锁和写锁请求都会阻塞。 也提供 RAII 机制，通过 RwLockReadGuard 和 RwLockWriteGuard。 同样是“poisoning”感知的。 何时使用： 当你的数据被频繁读取但很少写入时，RwLock 可以提供比 Mutex 更好的并发性能。例如，一个缓存系统或一个配置对象。 std::sync::Once (只运行一次) 用途： 确保某个代码块（一个初始化函数）在程序生命周期中只被执行一次，即使有多个线程同时尝试触发它。 特点： call_once() 方法会执行一个闭包。第一次调用会实际执行闭包，后续的调用会等待第一次调用完成，但不会再次执行闭包。 通常用于惰性初始化全局数据或单例模式。 何时使用： 初始化全局静态变量（例如日志系统、配置加载器）或实现单例模式。通常与 lazy_static crate (在稳定版 Rust 中) 或 std::sync::OnceLock (在 1.70&#43; 版本中，见下文) 结合使用。 std::sync::Barrier (屏障) 用途： 用于同步一组线程，确保所有线程都到达某个预定义点后才能继续执行。 特点： 通过 wait() 方法实现等待。当调用 wait() 的线程数量达到预设值时，所有等待的线程都会同时被释放。 wait() 返回一个 BarrierWaitResult，指示当前线程是否是最后一个到达屏障的。 何时使用： 需要协调多个并行任务的执行，例如在某个阶段结束后开始下一阶段，或者在所有子任务完成后进行汇总。 Rust 1.70&#43; 中引入的更现代的基于锁的 API：
" />
<meta property="og:url" content="https://chengzhycn.github.io/posts/2025-08/kaist-cs431-lock-based-api/" />
<meta property="og:site_name" content="chengzhycn&#39;s blog" />

  <meta property="og:image" content="https://chengzhycn.github.io/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">

  <meta property="article:section" content="Courses" />


  <meta property="article:published_time" content="2025-08-27 12:58:54 &#43;0800 &#43;0800" />












</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    chengzhycn&#39;s blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/">Home</a></li>
        
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/posts/">Archives</a></li>
        
      
        
          <li><a href="/categories/">Categories</a></li>
        
      
        
          <li><a href="/tags/">Tags</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/" >Home</a></li>
        
      
        
          <li><a href="/about" >About</a></li>
        
      
      
        <li>
          <ul class="menu">
            <li class="menu__trigger">Show more&nbsp;▾</li>
            <li>
              <ul class="menu__dropdown">
                
                  
                    <li><a href="/posts/" >Archives</a></li>
                  
                
                  
                    <li><a href="/categories/" >Categories</a></li>
                  
                
                  
                    <li><a href="/tags/" >Tags</a></li>
                  
                
              </ul>
            </li>
          </ul>
        </li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://chengzhycn.github.io/posts/2025-08/kaist-cs431-lock-based-api/">KAIST-CS431: Lock Based API</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-08-27</time><span class="post-reading-time">6 min read (1109 words)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://chengzhycn.github.io/tags/rust/">Rust</a>&nbsp;
      
      #<a href="https://chengzhycn.github.io/tags/concurrency/">Concurrency</a>&nbsp;
      
      #<a href="https://chengzhycn.github.io/tags/kaist-cs431/">KAIST-CS431</a>&nbsp;
      
    </span>
  
  


  
    <div class="table-of-contents">
      <h2>
        Table of Contents
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#标准库中的并发api">标准库中的并发API</a></li>
    <li><a href="#第三方库中的并发-api">第三方库中的并发 API</a>
      <ul>
        <li><a href="#parking_lot">parking_lot</a></li>
        <li><a href="#so-what-is-poisoning-anyway">So what is poisoning anyway?</a></li>
        <li><a href="#whats-wrong-with-lock-poisoning">What&rsquo;s wrong with lock poisoning?</a></li>
        <li><a href="#crossbeam">crossbeam</a></li>
        <li><a href="#rayon">rayon</a></li>
        <li><a href="#cs431">cs431</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <h2 id="标准库中的并发api">标准库中的并发API<a href="#标准库中的并发api" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Rust 标准库中基于锁的 API 主要围绕几个核心原语构建，这些原语提供了不同级别的并发控制和用途。它们都包含在 <code>std::sync</code> 模块中。以下是一些最常用的基于锁的 API：</p>
<ol>
<li><strong><code>std::sync::Mutex&lt;T&gt;</code> (互斥锁)</strong>
<ul>
<li><strong>用途：</strong> 最常见的互斥锁，用于保护共享数据，确保一次只有一个线程可以访问该数据。</li>
<li><strong>特点：</strong>
<ul>
<li>当线程尝试获取已被锁定的 Mutex 时，它会阻塞直到锁被释放。</li>
<li>提供内部可变性（<code>&amp;T</code> -&gt; <code>&amp;mut T</code>）通过 RAII (Resource Acquisition Is Initialization) 机制，即 <code>MutexGuard</code>。当 <code>MutexGuard</code> 离开作用域时，锁会自动释放。</li>
<li>是“poisoning”感知的：如果持有锁的线程在锁被释放前发生 panic，<code>Mutex</code> 会被标记为 poisoned。后续尝试获取锁的线程会得到一个 <code>PoisonError</code>，其中包含原始的 <code>MutexGuard</code>，允许它们决定如何处理被中断的数据。</li>
</ul>
</li>
<li><strong>何时使用：</strong> 当你需要独占访问某个共享资源时，例如全局计数器、数据结构或配置设置。</li>
</ul>
</li>
<li><strong><code>std::sync::RwLock&lt;T&gt;</code> (读写锁)</strong>
<ul>
<li><strong>用途：</strong> 允许多个读取者同时访问共享数据，但只允许一个写入者独占访问数据。</li>
<li><strong>特点：</strong>
<ul>
<li><strong>读取者（<code>read()</code>）：</strong> 允许多个线程并行获取读锁。只要没有写入者持有锁，所有读锁请求都会成功。</li>
<li><strong>写入者（<code>write()</code>）：</strong> 只允许一个线程获取写锁。当有写入者持有锁时，所有读锁和写锁请求都会阻塞。</li>
<li>也提供 RAII 机制，通过 <code>RwLockReadGuard</code> 和 <code>RwLockWriteGuard</code>。</li>
<li>同样是“poisoning”感知的。</li>
</ul>
</li>
<li><strong>何时使用：</strong> 当你的数据被频繁读取但很少写入时，<code>RwLock</code> 可以提供比 <code>Mutex</code> 更好的并发性能。例如，一个缓存系统或一个配置对象。</li>
</ul>
</li>
<li><strong><code>std::sync::Once</code> (只运行一次)</strong>
<ul>
<li><strong>用途：</strong> 确保某个代码块（一个初始化函数）在程序生命周期中只被执行一次，即使有多个线程同时尝试触发它。</li>
<li><strong>特点：</strong>
<ul>
<li><code>call_once()</code> 方法会执行一个闭包。第一次调用会实际执行闭包，后续的调用会等待第一次调用完成，但不会再次执行闭包。</li>
<li>通常用于惰性初始化全局数据或单例模式。</li>
</ul>
</li>
<li><strong>何时使用：</strong> 初始化全局静态变量（例如日志系统、配置加载器）或实现单例模式。通常与 <code>lazy_static</code> crate (在稳定版 Rust 中) 或 <code>std::sync::OnceLock</code> (在 1.70+ 版本中，见下文) 结合使用。</li>
</ul>
</li>
<li><strong><code>std::sync::Barrier</code> (屏障)</strong>
<ul>
<li><strong>用途：</strong> 用于同步一组线程，确保所有线程都到达某个预定义点后才能继续执行。</li>
<li><strong>特点：</strong>
<ul>
<li>通过 <code>wait()</code> 方法实现等待。当调用 <code>wait()</code> 的线程数量达到预设值时，所有等待的线程都会同时被释放。</li>
<li><code>wait()</code> 返回一个 <code>BarrierWaitResult</code>，指示当前线程是否是最后一个到达屏障的。</li>
</ul>
</li>
<li><strong>何时使用：</strong> 需要协调多个并行任务的执行，例如在某个阶段结束后开始下一阶段，或者在所有子任务完成后进行汇总。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>Rust 1.70+ 中引入的更现代的基于锁的 API：</strong></p>
<p>自 Rust 1.70 版本开始，<code>std</code> 库引入了两个新的、更方便的 API，用于解决常见的同步问题：</p>
<ol>
<li><strong><code>std::sync::OnceLock&lt;T&gt;</code> (一次性锁桶)</strong>
<ul>
<li><strong>用途：</strong> 用于实现惰性、安全的单次初始化，特别适合静态和全局变量。它是 <code>lazy_static</code> crate 的标准库替代品。</li>
<li><strong>特点：</strong>
<ul>
<li><code>get_or_init()</code> 方法：如果 <code>OnceLock</code> 尚未初始化，它会使用提供的闭包初始化它，并返回一个对内部数据的引用。如果已经初始化，则直接返回引用。</li>
<li><strong>线程安全：</strong> 保证闭包只执行一次，并且所有线程都会看到相同的结果。</li>
<li>不需要手动 <code>Mutex</code> 或 <code>RwLock</code> 就能实现安全的惰性初始化。</li>
</ul>
</li>
<li><strong>何时使用：</strong> 初始化全局配置、数据库连接池、日志器等，尤其是在不确定这些资源何时会被首次访问时。</li>
</ul>
</li>
<li><strong><code>std::sync::LazyLock&lt;T&gt;</code> (惰性锁桶)</strong>
<ul>
<li><strong>用途：</strong> 类似于 <code>OnceLock</code>，但它在第一次访问时才进行初始化，且语法更为简洁，特别适合于 <code>static</code> 变量。它是 <code>lazy_static</code> crate 的标准库替代品。</li>
<li><strong>特点：</strong>
<ul>
<li><code>LazyLock</code> 是一个结构体，它包含一个值和初始化它的闭包，并在第一次通过 <code>Deref</code> 访问时才执行闭包。</li>
<li><strong>声明方式：</strong> 类似于 <code>static MY_VALUE: LazyLock&lt;MyType&gt; = LazyLock::new(|| my_initializer());</code></li>
<li>提供了比 <code>OnceLock</code> 更平滑的语法糖来处理初始化。</li>
</ul>
</li>
<li><strong>何时使用：</strong> 当你需要一个在程序启动时不立即初始化，而是在第一次使用时才初始化，并且在整个程序生命周期中都不会改变的 <code>static</code> 常量时。</li>
</ul>
</li>
</ol>
<h2 id="第三方库中的并发-api">第三方库中的并发 API<a href="#第三方库中的并发-api" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="parking_lot">parking_lot<a href="#parking_lot" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><a href="https://github.com/Amanieu/parking_lot">Amanieu/parking_lot: Compact and efficient synchronization primitives for Rust. Also provides an API for creating custom synchronization primitives. (github.com)</a></p>
<p>一个优化的第三方并发原语库。和标准库主要不同是parking_lot库中的mutex是没有<strong>lock poisoning</strong>的。正常情况下感觉用不到这个库。。。</p>
<p>关于<strong>lock poisoning</strong>的解释，可以参考官方博客：<a href="https://blog.rust-lang.org/2020/12/11/lock-poisoning-survey.html">Launching the Lock Poisoning Survey | Rust Blog (rust-lang.org)</a></p>
<blockquote>
<h3 id="so-what-is-poisoning-anyway">So what is poisoning anyway?<a href="#so-what-is-poisoning-anyway" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Let&rsquo;s say you have an <code>Account</code> that can update its balance:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="w"> </span><span class="n">Account</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">update_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">change</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">balance</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">change</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">changes</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">change</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Let&rsquo;s also say we have the invariant that <code>balance == changes.sum()</code>. We&rsquo;ll call this the <em>balance invariant</em>. So at any point when interacting with an <code>Account</code> you can always depend on its <code>balance</code> being the sum of its <code>changes</code>, thanks to the balance invariant.</p>
<p>There&rsquo;s a point in our <code>update_balance</code> method where the balance invariant isn&rsquo;t maintained though:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="w"> </span><span class="n">Account</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">update_balance</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">change</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">balance</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">change</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//      self.balance != self.changes.sum()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">changes</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">change</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>That seems ok, because we&rsquo;re in the middle of a method with exclusive access to our <code>Account</code> and everything is back to good when we return. There isn&rsquo;t a <code>Result</code> or <code>?</code> to be seen so we know there&rsquo;s no chance of an early return before the balance invariant is restored. Or so we think.</p>
<p>What if <code>self.changes.push</code> didn&rsquo;t return normally? What if it panicked instead without actually doing anything? Then we&rsquo;d return from <code>update_balance</code> early without restoring the balance invariant. That seems ok too, because a panic will start unwinding the thread it was called from, leaving no trace of any data it owned behind. Ignoring the <code>Drop</code> trait, no data means no broken invariants. Problem solved, right?</p>
<p>What if our <code>Account</code> wasn&rsquo;t owned by that thread that panicked? What if it was shared with other threads as a <code>Arc&lt;Mutex&lt;Account&gt;&gt;</code>? Unwinding one thread isn&rsquo;t going to protect other threads that could still access the <code>Account</code>, and they&rsquo;re not going to know that it&rsquo;s now invalid.</p>
<p>This is where poisoning comes in. The <code>Mutex</code> and <code>RwLock</code> types in the standard library use a strategy that makes panics (and by extension the possibility for broken invariants) observable. The next consumer of the lock, such as another thread that didn&rsquo;t unwind, can decide at that point what to do about it. This is done by storing a switch in the lock itself that&rsquo;s flipped when a panic causes a thread to unwind through its guard. Once that switch is flipped the lock is considered <em>poisoned</em>, and the next attempt to acquire it will receive an error instead of a guard.</p>
<p>The standard approach for dealing with a poisoned lock is to propagate the panic to the current thread by unwrapping the error it returns:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div><p>That way nobody can ever observe the possibly violated balance invariant on our shared <code>Account</code>.</p>
<p>That sounds great! So why would we want to remove it?</p>
<h3 id="whats-wrong-with-lock-poisoning">What&rsquo;s wrong with lock poisoning?<a href="#whats-wrong-with-lock-poisoning" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>There&rsquo;s nothing wrong with poisoning itself. It&rsquo;s an excellent pattern for dealing with failures that can leave behind unworkable state. The question we&rsquo;re really asking is whether it should be used by the <em>standard locks</em>, which are <code>std::sync::Mutex</code> and <code>std::sync::RwLock</code>. We&rsquo;re asking whether it&rsquo;s a standard lock&rsquo;s job to implement poisoning. Just to avoid any confusion, we&rsquo;ll distinguish the poisoning pattern from the API of the standard locks by calling the former <em>poisoning</em> and the latter <em>lock poisoning</em>. We&rsquo;re just talking about lock poisoning.</p>
<p>In the previous section we motivated poisoning as a way to protect us from possibly broken invariants. Lock poisoning isn&rsquo;t actually a tool for doing this in the way you might think. In general, a poisoned lock can&rsquo;t tell whether or not any invariants are <em>actually</em> broken. It assumes that a lock is shared, so is likely going to outlive any individual thread that can access it. It also assumes that if a panic leaves any data behind then it&rsquo;s more likely to be left in an unexpected state, because panics aren&rsquo;t part of normal control flow in Rust. Everything <em>could</em> be fine after a panic, but the standard lock can&rsquo;t guarantee it. Since there&rsquo;s no guarantee there&rsquo;s an escape hatch. We can always still get access to the state guarded by a poisoned lock:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap_or_else</span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">into_inner</span><span class="p">());</span><span class="w">
</span></span></span></code></pre></div><p>All Rust code needs to remain free from any possible undefined behavior in the presence of panics, so ignoring panics is always safe. Rust doesn&rsquo;t try guarantee all safe code is free from logic bugs, so broken invariants that don&rsquo;t potentially lead to undefined behavior aren&rsquo;t strictly considered unsafe. Since ignoring lock poisoning is also always safe it doesn&rsquo;t really give you a dependable tool to protect state from panics. You can always ignore it.</p>
<p>So lock poisoning doesn&rsquo;t give you a tool for guaranteeing safety in the presence of panics. What it does give you is a way to propagate those panics to other threads. The machinery needed to do this adds costs to using the standard locks. There&rsquo;s an ergonomic cost in having to call <code>.lock().unwrap()</code>, and a runtime cost in having to actually track state for panics.</p>
<p>With the standard locks you pay those costs whether you need to or not. That&rsquo;s not typically how APIs in the standard library work. Instead, you compose costs together so you only pay for what you need.</p></blockquote>
<h3 id="crossbeam">crossbeam<a href="#crossbeam" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><a href="https://github.com/crossbeam-rs/crossbeam">crossbeam-rs/crossbeam: Tools for concurrent programming in Rust (github.com)</a></p>
<p>一个并发编程的工具集，在标准库外提供了很多扩展。CS431的讲师也是其中的maintainer之一。</p>
<ul>
<li><a href="https://docs.rs/crossbeam-utils/latest/crossbeam_utils/thread/struct.Scope.html">Scope in crossbeam_utils::thread - Rust (docs.rs)</a>将线程的生命周期限制在一个scope内。
<ul>
<li>目的是为了安全地共享非<code>'static</code>的变量；</li>
<li>原理是通过添加一个scope，保证spawn的线程在scope的生命周期结束之前终止，来保证变量的安全性。</li>
</ul>
</li>
<li><a href="https://docs.rs/crossbeam-utils/latest/crossbeam_utils/struct.CachePadded.html">CachePadded in crossbeam_utils - Rust (docs.rs)</a> cacheline填充，避免伪共享。1</li>
<li><a href="https://docs.rs/crossbeam-channel/latest/crossbeam_channel/index.html">crossbeam_channel - Rust (docs.rs)</a> 一个类似于Go中的channel的multi-producer multi-consumer的channel库。同时还提供了<code>select!</code>原语提供Go中<code>select</code>多信道监听的功能。</li>
</ul>
<h4 id="伪共享">伪共享<a href="#伪共享" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p><a href="https://parallelcomputing2017.wordpress.com/2017/03/17/understanding-false-sharing/">Understanding False Sharing – Parallel Computing (wordpress.com)</a></p>
<h3 id="rayon">rayon<a href="#rayon" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p><a href="https://github.com/rayon-rs/rayon">rayon-rs/rayon: Rayon: A data parallelism library for Rust (github.com)</a></p>
<p>Rayon 是一个Rust的数据并行计算库。它非常轻巧，可以轻松地将顺序计算转换为并行计算。同时保证不会有数据争用情况出现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">rayon</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">sum_of_squares</span><span class="p">(</span><span class="n">input</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">i32</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">input</span><span class="p">.</span><span class="n">par_iter</span><span class="p">()</span><span class="w"> </span><span class="c1">// &lt;-- just change that!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">         </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="p">.</span><span class="n">sum</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="cs431">cs431<a href="#cs431" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>作者自己实现的一个Lock Based API，可以参考学习锁机制。</p>
<p><a href="https://github.com/kaist-cp/cs431/blob/main/lock/src/spinlock.rs">cs431/spinlock.rs at main · kaist-cp/cs431 (github.com)</a></p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">Read other posts</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://chengzhycn.github.io/posts/2025-08/kaist-cs431-nondeterminisms-of-shared-memory-concurrency/" class="button inline prev">
        &lt; [<span class="button__text">KAIST-CS431: Nondeterminisms of Shared-memory Concurrency</span>]
      </a>
    
    
      ::
    
    
      <a href="https://chengzhycn.github.io/posts/2025-08/wasm-internals-overview/" class="button inline next">
         [<span class="button__text">Wasm Internals - Overview</span>] &gt;
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
