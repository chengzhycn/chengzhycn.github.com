<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on chengzhycn&#39;s blog</title>
    <link>https://chengzhycn.github.io/posts/</link>
    <description>Recent content in Posts on chengzhycn&#39;s blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 27 Aug 2025 13:40:27 +0800</lastBuildDate>
    <atom:link href="https://chengzhycn.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>KAIST-CS431: Promising Semantics</title>
      <link>https://chengzhycn.github.io/posts/2025-08/kaist-cs431-promising-semantics/</link>
      <pubDate>Wed, 27 Aug 2025 13:40:27 +0800</pubDate>
      <guid>https://chengzhycn.github.io/posts/2025-08/kaist-cs431-promising-semantics/</guid>
      <description>&lt;p&gt;本章是基于作者的研究“Promising semantics”: &lt;a href=&#34;https://sf.snu.ac.kr/promise-concurrency/&#34;&gt;https://sf.snu.ac.kr/promise-concurrency/&lt;/a&gt; ，提出的一种对宽松内存（relaxed-memory）并发的建模方法。&lt;/p&gt;&#xA;&lt;p&gt;主要观点有4个：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;modeling load hoisting w/ &lt;strong&gt;multi-valued memory&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;允许一个线程从某个位置读取到一个旧值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;modeling read-modify-write w/ &lt;strong&gt;message adjacency&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;禁止对单个值同时进行多个read-modify-write操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;modeling coherence &amp;amp; ordering w/ &lt;strong&gt;views&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;限制线程的行为&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;modeling store hoisting w/ &lt;strong&gt;promises&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Allowing a thread to speculatively write a value&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;个人理解，**即便是编译器/硬件的指令重排，也是需要遵循一定的规则的，不能随意乱排。**作者从值读取、存储、read-modify-write多种角度对线程的行为进行了建模，是为了解释哪些情况下出现多线程执行出现哪些结果是可能的，哪些是不被允许的。&lt;/p&gt;&#xA;&lt;p&gt;hoisting load/store在网上没有搜到解释，但是有个gcc的优化提到了这个概念。大概意思时将存值/取值操作从原先的指令顺序中调整位置，优化执行效率。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://gcc.gnu.org/news/hoist.html&#34;&gt;Load/Store Hoisting - GNU Project&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;multi-value-memory&#34;&gt;multi-value memory&lt;/h2&gt;&#xA;&lt;p&gt;内存是一系列消息（message）所在的位置，而消息可以看作是&lt;strong&gt;值和时间戳&lt;/strong&gt;的组合。线程很有可能在读取时从内存中读到一个旧值。（effectively hoisting loads）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://chengzhycn.github.io/images/notes/kaist-cs431-promising-semantics/image-20220318080820894.png&#34; alt=&#34;image-20220318080820894&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在作者举的例子中，r1=r2=0是被允许的，因为r1 r2都有可能从Y X中读到一个旧值。从后文的view角度理解，因为在独立的线程中，X和Y的赋值并没有改变当前线程中相应Y和X的view，所以，r1 r2的读取操作是可以读到旧值的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;message-adjacency&#34;&gt;message adjacency&lt;/h2&gt;&#xA;&lt;p&gt;上面说了，消息是值和时间戳范围的组合。read-modify-write操作修改了消息的值，在时间轴上应该和前值紧邻在一起（no gap）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://chengzhycn.github.io/images/notes/kaist-cs431-promising-semantics/image-20220318081606125.png&#34; alt=&#34;image-20220318081606125&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以看到，两次fetch_add操作后，从X的视角上看，0、1、2是紧邻的。第二次fetch_add操作，只能紧贴着1操作，而不能插到0和1之间。&lt;/p&gt;&#xA;&lt;h2 id=&#34;views&#34;&gt;views&lt;/h2&gt;&#xA;&lt;p&gt;这个semantics对我是启发性最强的一章。&lt;/p&gt;&#xA;&lt;p&gt;multi-valued memory允许了太多不在预期中的行为，因此我们需要做些限制，保证一致性和同步。&lt;/p&gt;&#xA;&lt;p&gt;View分为三种，分别是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Per-thread view：一致性&lt;/li&gt;&#xA;&lt;li&gt;Per-message view：release/acquire同步&lt;/li&gt;&#xA;&lt;li&gt;Global view：SC同步&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;per-thread-view&#34;&gt;Per-thread view&lt;/h3&gt;&#xA;&lt;p&gt;Per-thread view表示线程对消息的确认。&lt;/p&gt;</description>
    </item>
    <item>
      <title>KAIST-CS431: Nondeterminisms of Shared-memory Concurrency</title>
      <link>https://chengzhycn.github.io/posts/2025-08/kaist-cs431-nondeterminisms-of-shared-memory-concurrency/</link>
      <pubDate>Wed, 27 Aug 2025 13:31:59 +0800</pubDate>
      <guid>https://chengzhycn.github.io/posts/2025-08/kaist-cs431-nondeterminisms-of-shared-memory-concurrency/</guid>
      <description>&lt;h2 id=&#34;nondeterminism&#34;&gt;Nondeterminism&lt;/h2&gt;&#xA;&lt;h3 id=&#34;thread-interleaving&#34;&gt;thread interleaving&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;interleaving semantics：&lt;/strong&gt; 将多线程的指令交替组合成好像是单线程执行一样。&lt;/p&gt;&#xA;&lt;p&gt;不同线程间的Load/store指令是穿插执行的，导致最终的行为有多种多样的可能。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;no&#34;&gt;COUNTER&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AtomicUsize&lt;/span&gt;::&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// thread A &amp;amp; B&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;no&#34;&gt;COUNTER&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;COUNTER&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上示例，两个线程A和B同时对COUNTER进行+1操作，预期结果当然是2。但是&lt;strong&gt;由于线程调度的不确定性&lt;/strong&gt;可能出现如下的执行顺序：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[COUNTER=0] A load, B load, A store, B store [COUNTER=1]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;导致结果不符合预期。&lt;/p&gt;&#xA;&lt;h4 id=&#34;解决方案&#34;&gt;解决方案&lt;/h4&gt;&#xA;&lt;p&gt;使用原子的reading &amp;amp; writing，禁止掉这种不符预期的执行顺序。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// thread A &amp;amp; B&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;no&#34;&gt;COUNTER&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fetch_and_add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;“Read-modify-write”&lt;/strong&gt;, e.g. swap, compare-and-swap, fetch-and-add&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;reordering&#34;&gt;reordering&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;同一个线程中的指令会因为硬件和编译器的优化发生指令重排。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DATA = 42;       ||   if FLAG.load() {&#xA;FLAG.store(1);   ||       assert(DATA == 42);&#xA;                 ||   }&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上图示例，预期是当&lt;code&gt;FLAG.load()&lt;/code&gt;为1时，&lt;code&gt;DATA == 42&lt;/code&gt;。但是因为指令重排，左边线程中，&lt;code&gt;FLAG.store(1)&lt;/code&gt;可能发生在赋值语句前面；右边线程中assert语句也可能发生在if语句前面。&lt;/p&gt;</description>
    </item>
    <item>
      <title>KAIST-CS431: Lock Based API</title>
      <link>https://chengzhycn.github.io/posts/2025-08/kaist-cs431-lock-based-api/</link>
      <pubDate>Wed, 27 Aug 2025 12:58:54 +0800</pubDate>
      <guid>https://chengzhycn.github.io/posts/2025-08/kaist-cs431-lock-based-api/</guid>
      <description>&lt;h2 id=&#34;标准库中的并发api&#34;&gt;标准库中的并发API&lt;/h2&gt;&#xA;&lt;p&gt;Rust 标准库中基于锁的 API 主要围绕几个核心原语构建，这些原语提供了不同级别的并发控制和用途。它们都包含在 &lt;code&gt;std::sync&lt;/code&gt; 模块中。以下是一些最常用的基于锁的 API：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;std::sync::Mutex&amp;lt;T&amp;gt;&lt;/code&gt; (互斥锁)&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 最常见的互斥锁，用于保护共享数据，确保一次只有一个线程可以访问该数据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当线程尝试获取已被锁定的 Mutex 时，它会阻塞直到锁被释放。&lt;/li&gt;&#xA;&lt;li&gt;提供内部可变性（&lt;code&gt;&amp;amp;T&lt;/code&gt; -&amp;gt; &lt;code&gt;&amp;amp;mut T&lt;/code&gt;）通过 RAII (Resource Acquisition Is Initialization) 机制，即 &lt;code&gt;MutexGuard&lt;/code&gt;。当 &lt;code&gt;MutexGuard&lt;/code&gt; 离开作用域时，锁会自动释放。&lt;/li&gt;&#xA;&lt;li&gt;是“poisoning”感知的：如果持有锁的线程在锁被释放前发生 panic，&lt;code&gt;Mutex&lt;/code&gt; 会被标记为 poisoned。后续尝试获取锁的线程会得到一个 &lt;code&gt;PoisonError&lt;/code&gt;，其中包含原始的 &lt;code&gt;MutexGuard&lt;/code&gt;，允许它们决定如何处理被中断的数据。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;何时使用：&lt;/strong&gt; 当你需要独占访问某个共享资源时，例如全局计数器、数据结构或配置设置。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;std::sync::RwLock&amp;lt;T&amp;gt;&lt;/code&gt; (读写锁)&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 允许多个读取者同时访问共享数据，但只允许一个写入者独占访问数据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;读取者（&lt;code&gt;read()&lt;/code&gt;）：&lt;/strong&gt; 允许多个线程并行获取读锁。只要没有写入者持有锁，所有读锁请求都会成功。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;写入者（&lt;code&gt;write()&lt;/code&gt;）：&lt;/strong&gt; 只允许一个线程获取写锁。当有写入者持有锁时，所有读锁和写锁请求都会阻塞。&lt;/li&gt;&#xA;&lt;li&gt;也提供 RAII 机制，通过 &lt;code&gt;RwLockReadGuard&lt;/code&gt; 和 &lt;code&gt;RwLockWriteGuard&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;同样是“poisoning”感知的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;何时使用：&lt;/strong&gt; 当你的数据被频繁读取但很少写入时，&lt;code&gt;RwLock&lt;/code&gt; 可以提供比 &lt;code&gt;Mutex&lt;/code&gt; 更好的并发性能。例如，一个缓存系统或一个配置对象。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;std::sync::Once&lt;/code&gt; (只运行一次)&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 确保某个代码块（一个初始化函数）在程序生命周期中只被执行一次，即使有多个线程同时尝试触发它。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;call_once()&lt;/code&gt; 方法会执行一个闭包。第一次调用会实际执行闭包，后续的调用会等待第一次调用完成，但不会再次执行闭包。&lt;/li&gt;&#xA;&lt;li&gt;通常用于惰性初始化全局数据或单例模式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;何时使用：&lt;/strong&gt; 初始化全局静态变量（例如日志系统、配置加载器）或实现单例模式。通常与 &lt;code&gt;lazy_static&lt;/code&gt; crate (在稳定版 Rust 中) 或 &lt;code&gt;std::sync::OnceLock&lt;/code&gt; (在 1.70+ 版本中，见下文) 结合使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;std::sync::Barrier&lt;/code&gt; (屏障)&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;用途：&lt;/strong&gt; 用于同步一组线程，确保所有线程都到达某个预定义点后才能继续执行。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;特点：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过 &lt;code&gt;wait()&lt;/code&gt; 方法实现等待。当调用 &lt;code&gt;wait()&lt;/code&gt; 的线程数量达到预设值时，所有等待的线程都会同时被释放。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt; 返回一个 &lt;code&gt;BarrierWaitResult&lt;/code&gt;，指示当前线程是否是最后一个到达屏障的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;何时使用：&lt;/strong&gt; 需要协调多个并行任务的执行，例如在某个阶段结束后开始下一阶段，或者在所有子任务完成后进行汇总。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;Rust 1.70+ 中引入的更现代的基于锁的 API：&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Wasm Internals - Overview</title>
      <link>https://chengzhycn.github.io/posts/2025-08/wasm-internals-overview/</link>
      <pubDate>Tue, 26 Aug 2025 12:29:03 +0800</pubDate>
      <guid>https://chengzhycn.github.io/posts/2025-08/wasm-internals-overview/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://rsms.me/wasm-intro&#34;&gt;https://rsms.me/wasm-intro&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/&#34;&gt;https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;wasm-的历史发展&#34;&gt;Wasm 的历史发展&lt;/h2&gt;&#xA;&lt;h3 id=&#34;早期wasm-mvp---2017&#34;&gt;早期（Wasm MVP - 2017）&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;诞生背景：&lt;/strong&gt; Wasm 的设计目标是为了替代 asm.js，提供更小、更快、更安全的 Web 二进制格式。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;核心模块的初步定义：&lt;/strong&gt; MVP（Minimum Viable Product）阶段定义了 Wasm Core Module 的基本结构：函数、内存、表、导入、导出、全局变量等。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;主要用例：&lt;/strong&gt; 游戏引擎、音视频编解码、计算密集型任务等。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;限制：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;没有模块化系统：&lt;/strong&gt; 模块之间没有标准的链接机制，只能通过宿主环境（如 JavaScript）进行协调。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;缺乏垃圾回收（GC）：&lt;/strong&gt; 需要手动内存管理或使用语言自带的 GC 机制（如 Emscripten 的 mimalloc）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;没有线程：&lt;/strong&gt; 无法直接利用多核 CPU。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;没有宿主 API 标准化：&lt;/strong&gt; 模块与宿主环境的交互方式高度依赖宿主（如浏览器），没有统一的接口定义。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;没有组件模型：&lt;/strong&gt; 模块重用和组合非常困难。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;中期mvp-之后---持续演进&#34;&gt;中期（MVP 之后 - 持续演进）&lt;/h3&gt;&#xA;&lt;p&gt;Wasm 社区和工作组认识到 MVP 的局限性，并开始着手扩展 Wasm 的能力，这直接影响了 Core Module 的能力：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;多值（Multiple Returns &amp;amp; Parameters）：&lt;/strong&gt; 允许函数返回多个值，接收多个参数，提高表达能力。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;引用类型（Reference Types）：&lt;/strong&gt; 引入了 &lt;code&gt;externref&lt;/code&gt; 和 &lt;code&gt;funcref&lt;/code&gt;，允许 Wasm 直接引用宿主对象和函数，而无需通过数字 ID 传递，为未来的 GC 和组件模型打下基础。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;固定大小的 SIMD（Fixed-width SIMD）：&lt;/strong&gt; 引入了新的指令集，允许在 Wasm 中进行向量化操作，进一步提升某些计算密集型任务的性能。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;线程（Threads）：&lt;/strong&gt; 引入了共享内存和原子操作，允许 Wasm 模块在多线程环境下运行，极大地提升了并行计算能力。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;内存增长和限制（Memory Growth and Limits）：&lt;/strong&gt; 提供了更灵活的内存管理机制。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Tail Calls（尾调用）：&lt;/strong&gt; 优化了函数调用的性能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;近期和未来wasm-component-model&#34;&gt;近期和未来（Wasm Component Model）&lt;/h3&gt;&#xA;&lt;p&gt;这是 Wasm 发展中最重要的方向之一，旨在解决 Core Module 在模块化和互操作性方面的根本性问题：&lt;/p&gt;</description>
    </item>
    <item>
      <title>C³: Common Coding Conventions</title>
      <link>https://chengzhycn.github.io/posts/2025-03/c-common-coding-conventions/</link>
      <pubDate>Sat, 29 Mar 2025 13:52:28 +0800</pubDate>
      <guid>https://chengzhycn.github.io/posts/2025-03/c-common-coding-conventions/</guid>
      <description>&lt;h1 id=&#34;c-common-coding-conventions&#34;&gt;C³: Common Coding Conventions&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://google.github.io/eng-practices/&#34;&gt;https://google.github.io/eng-practices/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/tum-esi/common-coding-conventions&#34;&gt;https://github.com/tum-esi/common-coding-conventions&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;The goal of these conventions is to be concise, universal, and remarkable. It targets emerging code enthusiasts under time pressure and covers 7 topics:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://chengzhycn.github.io/posts/2025-03/c-common-coding-conventions/#user-content-general-clarifications&#34;&gt;General Clarifications&lt;/a&gt;,&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://chengzhycn.github.io/posts/2025-03/c-common-coding-conventions/#user-content-architecture&#34;&gt;Architecture&lt;/a&gt;,&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://chengzhycn.github.io/posts/2025-03/c-common-coding-conventions/#user-content-implementation&#34;&gt;Implementation&lt;/a&gt;,&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://chengzhycn.github.io/posts/2025-03/c-common-coding-conventions/#user-content-naming&#34;&gt;Naming&lt;/a&gt;,&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://chengzhycn.github.io/posts/2025-03/c-common-coding-conventions/#user-content-code-layout&#34;&gt;Code Layout&lt;/a&gt;,&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://chengzhycn.github.io/posts/2025-03/c-common-coding-conventions/#user-content-documentation&#34;&gt;Documentation&lt;/a&gt;, and&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://chengzhycn.github.io/posts/2025-03/c-common-coding-conventions/#user-content-languages&#34;&gt;Languages&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;To follow this guide, you should already have heard about &lt;a href=&#34;https://www.educative.io/blog/object-oriented-programming&#34;&gt;Object Oriented Programming&lt;/a&gt; and know basic programming rules, such as writing loops and meaningful functions instead of copy pasting&#xA;instructions. In this Readme, we will shortly summarize the most important rules for every topic.&lt;/p&gt;</description>
    </item>
    <item>
      <title>KAIST-CS431: Lock</title>
      <link>https://chengzhycn.github.io/posts/2022-03/kaist-cs431-lock/</link>
      <pubDate>Tue, 08 Mar 2022 00:00:00 +0000</pubDate>
      <guid>https://chengzhycn.github.io/posts/2022-03/kaist-cs431-lock/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Pros &amp;amp; cons:&lt;/strong&gt; simple &amp;amp; possibly inefficient&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;low-level-lock-api&#34;&gt;Low-Level Lock API&lt;/h2&gt;&#xA;&lt;p&gt;常用的low-level锁的API有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Lock.acquire()&lt;/strong&gt;: 阻塞，直到获取到锁&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Lock.try_acquire():&lt;/strong&gt; 返回锁是否已经被占用了，如果是，返回false，否，占用锁并返回true。不阻塞&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Lock.release()&lt;/strong&gt;: 释放锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;acquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;acquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;r2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;release&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是，这些API给用户在使用时造成了很多挑战（心智负担）：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Relating lock and resource&lt;/strong&gt;: 用户只有在拿到锁时才能访问被保护的变量；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Matching acquire/release&lt;/strong&gt;: 用户只能释放已经拿到的锁。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如果锁没有得到正确的处理，会造成很多潜在的问题，并且，这些问题很难发现。因此，在并发编程时，low-level的锁API存在如下问题：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;High cost&lt;/strong&gt;：程序员需要始终关注API的使用；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Potential bugs&lt;/strong&gt;：不正确的使用容易造成很多潜在的bugs。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;high-level-lock-api&#34;&gt;High-Level Lock API&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;想要一个易用地，始终能保证安全地high-level API。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Acquire/release自动匹配；&lt;/li&gt;&#xA;&lt;li&gt;Lock和resource显式关联。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;C++中，这种API被称作&lt;strong&gt;RAII&lt;/strong&gt;：&lt;strong&gt;Resource Acquisition Is Initialization&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;mutex&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;fstream&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdexcept&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;write_to_file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 创建关于文件的互斥锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 在访问文件前进行加锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock_guard&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 尝试打开文件&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ofstream&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;example.txt&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;runtime_error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;unable to open file&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 输出文件内容&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;file&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 当离开作用域时，文件句柄会被首先析构 (不管是否抛出了异常)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 互斥锁也会被析构 (同样地，不管是否抛出了异常)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;RAII要求，资源的有效期与持有资源的&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%e5%af%b9%e8%b1%a1%e7%9a%84%e7%94%9f%e5%91%bd%e6%9c%9f&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;对象的生命期&lt;/a&gt;严格绑定，即由对象的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&#34;&gt;构造函数&lt;/a&gt;完成&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%e8%b5%84%e6%ba%90%e7%9a%84%e5%88%86%e9%85%8d&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;资源的分配&lt;/a&gt;（获取），同时由&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&#34;&gt;析构函数&lt;/a&gt;完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%e8%b5%84%e6%ba%90%e6%b3%84%e9%9c%b2&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;资源泄露&lt;/a&gt;问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dns Zone Files</title>
      <link>https://chengzhycn.github.io/posts/2021-01/dns-zone-files/</link>
      <pubDate>Sun, 03 Jan 2021 10:18:55 +0800</pubDate>
      <guid>https://chengzhycn.github.io/posts/2021-01/dns-zone-files/</guid>
      <description>&lt;h2 id=&#34;cname-记录&#34;&gt;CNAME 记录&lt;/h2&gt;&#xA;&lt;h3 id=&#34;记录格式&#34;&gt;记录格式&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bar.example.com.&#x9;CNAME&#x9;foo.example.com.&#xA;foo.example.com.&#x9;A&#x9;&#x9;192.168.0.1&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;cname-记录的限制&#34;&gt;CNAME 记录的限制&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果一个 domain name 有了一个 CNAME 记录，那么它不能再拥有其它类型的记录&lt;/li&gt;&#xA;&lt;li&gt;CNAME 记录必须指向另外一个 domain name，而不是一个 IP&lt;/li&gt;&#xA;&lt;li&gt;CNAME 记录最好不要指向另外一个 CNAME 记录&lt;/li&gt;&#xA;&lt;li&gt;MX 和 NS 记录不能指向一个 CNAME 记录&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;srv-记录&#34;&gt;SRV 记录&lt;/h2&gt;&#xA;&lt;p&gt;type code：33&lt;/p&gt;&#xA;&lt;h3 id=&#34;记录格式-1&#34;&gt;记录格式&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;_service._protocol.name. TTL class SRV priority weight port target.&#xA;&#xA;_sip._tcp.example.com. 86400 IN SRV 0 5 5060 sipserver.example.com.&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;_service: 服务名称 symbolic name&lt;/li&gt;&#xA;&lt;li&gt;protocol: 协议&lt;/li&gt;&#xA;&lt;li&gt;name: domain name，以 . 结束&lt;/li&gt;&#xA;&lt;li&gt;priority: 条目优先级, 值越低优先级越高&lt;/li&gt;&#xA;&lt;li&gt;weight: 同样优先级内不同条目的权重&lt;/li&gt;&#xA;&lt;li&gt;target: canonical hostname，以 . 结束&#xA;如果是一个 MX 记录，那么 target 需要是一个 IP 地址（A 或者 AAAA）而不是 CNAME&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;soa-记录&#34;&gt;SOA 记录&lt;/h2&gt;&#xA;&lt;p&gt;start of authority, 一个权威的起始&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
