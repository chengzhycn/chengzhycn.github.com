<!DOCTYPE html>
<html lang="en">
<head>
	<meta name="generator" content="Hugo 0.149.0">
  
    <title>chengzhycn&#39;s blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Better work, better life" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://chengzhycn.github.io/" />





  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/fonts.min.176c65cdf7082e9866e90b1fa123c60056f6d985b7cd3c4235600dada719e971.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/main.min.0909aaaf12e6fc3cdf2758321db2805239dc85602baff9dc07ce57d3d7365095.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/menu.min.310d32205bdedd6f43144e3c3273c9deecd238eba5f9108db5ea96ca0cfbe377.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/post.min.ad50c7f4d00e7975918f37fc74c6029e1959a40d66fb5b2c6564a8715e985573.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/syntax.min.e9ab635cf918bc84b901eb65c0b2caa74c9544245e3647c1af5c129896ef276e.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">

  
  <link rel="stylesheet" href="https://chengzhycn.github.io/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="https://chengzhycn.github.io/favicon.png">
<link rel="apple-touch-icon" href="https://chengzhycn.github.io/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="website" />
<meta property="og:title" content="chengzhycn&#39;s blog">
<meta property="og:description" content="Better work, better life" />
<meta property="og:url" content="https://chengzhycn.github.io/" />
<meta property="og:site_name" content="chengzhycn&#39;s blog" />

  <meta property="og:image" content="https://chengzhycn.github.io/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">





  <link href="/index.xml" rel="alternate" type="application/rss+xml" title="chengzhycn&#39;s blog" />









</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    chengzhycn&#39;s blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/">Home</a></li>
        
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/posts/">Archives</a></li>
        
      
        
          <li><a href="/categories/">Categories</a></li>
        
      
        
          <li><a href="/tags/">Tags</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/" >Home</a></li>
        
      
        
          <li><a href="/about" >About</a></li>
        
      
      
        <li>
          <ul class="menu">
            <li class="menu__trigger">Show more&nbsp;▾</li>
            <li>
              <ul class="menu__dropdown">
                
                  
                    <li><a href="/posts/" >Archives</a></li>
                  
                
                  
                    <li><a href="/categories/" >Categories</a></li>
                  
                
                  
                    <li><a href="/tags/" >Tags</a></li>
                  
                
              </ul>
            </li>
          </ul>
        </li>
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
  
  <div class="posts">
    
    

    
    
      
    
    

    
      <article class="post on-list">
        <h2 class="post-title">
          <a href="https://chengzhycn.github.io/posts/2025-08/kaist-cs431-promising-semantics/">KAIST-CS431: Promising Semantics</a>
        </h2>

        <div class="post-meta"><time class="post-date">2025-08-27</time></div>

        
          <span class="post-tags">
            
            #<a href="https://chengzhycn.github.io/tags/rust/">Rust</a>&nbsp;
            
            #<a href="https://chengzhycn.github.io/tags/concurrency/">Concurrency</a>&nbsp;
            
            #<a href="https://chengzhycn.github.io/tags/kaist-cs431/">KAIST-CS431</a>&nbsp;
            
          </span>
        

        


        <div class="post-content">
          
            <p>本章是基于作者的研究“Promising semantics”: <a href="https://sf.snu.ac.kr/promise-concurrency/">https://sf.snu.ac.kr/promise-concurrency/</a> ，提出的一种对宽松内存（relaxed-memory）并发的建模方法。</p>
<p>主要观点有4个：</p>
<ul>
<li>modeling load hoisting w/ <strong>multi-valued memory</strong>
<ul>
<li>允许一个线程从某个位置读取到一个旧值</li>
</ul>
</li>
<li>modeling read-modify-write w/ <strong>message adjacency</strong>
<ul>
<li>禁止对单个值同时进行多个read-modify-write操作</li>
</ul>
</li>
<li>modeling coherence &amp; ordering w/ <strong>views</strong>
<ul>
<li>限制线程的行为</li>
</ul>
</li>
<li>modeling store hoisting w/ <strong>promises</strong>
<ul>
<li>Allowing a thread to speculatively write a value</li>
</ul>
</li>
</ul>
<p>个人理解，**即便是编译器/硬件的指令重排，也是需要遵循一定的规则的，不能随意乱排。**作者从值读取、存储、read-modify-write多种角度对线程的行为进行了建模，是为了解释哪些情况下出现多线程执行出现哪些结果是可能的，哪些是不被允许的。</p>
<p>hoisting load/store在网上没有搜到解释，但是有个gcc的优化提到了这个概念。大概意思时将存值/取值操作从原先的指令顺序中调整位置，优化执行效率。</p>
<p><a href="https://gcc.gnu.org/news/hoist.html">Load/Store Hoisting - GNU Project</a></p>
<h2 id="multi-value-memory">multi-value memory</h2>
<p>内存是一系列消息（message）所在的位置，而消息可以看作是<strong>值和时间戳</strong>的组合。线程很有可能在读取时从内存中读到一个旧值。（effectively hoisting loads）</p>
<p><img src="/images/notes/kaist-cs431-promising-semantics/image-20220318080820894.png" alt="image-20220318080820894"></p>
<p>在作者举的例子中，r1=r2=0是被允许的，因为r1 r2都有可能从Y X中读到一个旧值。从后文的view角度理解，因为在独立的线程中，X和Y的赋值并没有改变当前线程中相应Y和X的view，所以，r1 r2的读取操作是可以读到旧值的。</p>
<h2 id="message-adjacency">message adjacency</h2>
<p>上面说了，消息是值和时间戳范围的组合。read-modify-write操作修改了消息的值，在时间轴上应该和前值紧邻在一起（no gap）。</p>
<p><img src="/images/notes/kaist-cs431-promising-semantics/image-20220318081606125.png" alt="image-20220318081606125"></p>
<p>可以看到，两次fetch_add操作后，从X的视角上看，0、1、2是紧邻的。第二次fetch_add操作，只能紧贴着1操作，而不能插到0和1之间。</p>
<h2 id="views">views</h2>
<p>这个semantics对我是启发性最强的一章。</p>
<p>multi-valued memory允许了太多不在预期中的行为，因此我们需要做些限制，保证一致性和同步。</p>
<p>View分为三种，分别是：</p>
<ul>
<li>Per-thread view：一致性</li>
<li>Per-message view：release/acquire同步</li>
<li>Global view：SC同步</li>
</ul>
<h3 id="per-thread-view">Per-thread view</h3>
<p>Per-thread view表示线程对消息的确认。</p>
          
        </div>

        
          <div>
            <a class="read-more button inline" href="/posts/2025-08/kaist-cs431-promising-semantics/">[Read more]</a>
          </div>
        
      </article>
    
      <article class="post on-list">
        <h2 class="post-title">
          <a href="https://chengzhycn.github.io/posts/2025-08/kaist-cs431-nondeterminisms-of-shared-memory-concurrency/">KAIST-CS431: Nondeterminisms of Shared-memory Concurrency</a>
        </h2>

        <div class="post-meta"><time class="post-date">2025-08-27</time></div>

        
          <span class="post-tags">
            
            #<a href="https://chengzhycn.github.io/tags/rust/">Rust</a>&nbsp;
            
            #<a href="https://chengzhycn.github.io/tags/concurrency/">Concurrency</a>&nbsp;
            
            #<a href="https://chengzhycn.github.io/tags/kaist-cs431/">KAIST-CS431</a>&nbsp;
            
          </span>
        

        


        <div class="post-content">
          
            <h2 id="nondeterminism">Nondeterminism</h2>
<h3 id="thread-interleaving">thread interleaving</h3>
<p><strong>interleaving semantics：</strong> 将多线程的指令交替组合成好像是单线程执行一样。</p>
<p>不同线程间的Load/store指令是穿插执行的，导致最终的行为有多种多样的可能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">static</span><span class="w"> </span><span class="no">COUNTER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AtomicUsize</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// thread A &amp; B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">COUNTER</span><span class="p">.</span><span class="n">load</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="no">COUNTER</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>如上示例，两个线程A和B同时对COUNTER进行+1操作，预期结果当然是2。但是<strong>由于线程调度的不确定性</strong>可能出现如下的执行顺序：</p>
<pre tabindex="0"><code>[COUNTER=0] A load, B load, A store, B store [COUNTER=1]
</code></pre><p>导致结果不符合预期。</p>
<h4 id="解决方案">解决方案</h4>
<p>使用原子的reading &amp; writing，禁止掉这种不符预期的执行顺序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// thread A &amp; B
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">COUNTER</span><span class="p">.</span><span class="n">fetch_and_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><strong>“Read-modify-write”</strong>, e.g. swap, compare-and-swap, fetch-and-add</li>
</ul>
<h3 id="reordering">reordering</h3>
<p><strong>同一个线程中的指令会因为硬件和编译器的优化发生指令重排。</strong></p>
<pre tabindex="0"><code>DATA = 42;       ||   if FLAG.load() {
FLAG.store(1);   ||       assert(DATA == 42);
                 ||   }
</code></pre><p>如上图示例，预期是当<code>FLAG.load()</code>为1时，<code>DATA == 42</code>。但是因为指令重排，左边线程中，<code>FLAG.store(1)</code>可能发生在赋值语句前面；右边线程中assert语句也可能发生在if语句前面。</p>
          
        </div>

        
          <div>
            <a class="read-more button inline" href="/posts/2025-08/kaist-cs431-nondeterminisms-of-shared-memory-concurrency/">[Read more]</a>
          </div>
        
      </article>
    
      <article class="post on-list">
        <h2 class="post-title">
          <a href="https://chengzhycn.github.io/posts/2025-08/kaist-cs431-lock-based-api/">KAIST-CS431: Lock Based API</a>
        </h2>

        <div class="post-meta"><time class="post-date">2025-08-27</time></div>

        
          <span class="post-tags">
            
            #<a href="https://chengzhycn.github.io/tags/rust/">Rust</a>&nbsp;
            
            #<a href="https://chengzhycn.github.io/tags/concurrency/">Concurrency</a>&nbsp;
            
            #<a href="https://chengzhycn.github.io/tags/kaist-cs431/">KAIST-CS431</a>&nbsp;
            
          </span>
        

        


        <div class="post-content">
          
            <h2 id="标准库中的并发api">标准库中的并发API</h2>
<p>Rust 标准库中基于锁的 API 主要围绕几个核心原语构建，这些原语提供了不同级别的并发控制和用途。它们都包含在 <code>std::sync</code> 模块中。以下是一些最常用的基于锁的 API：</p>
<ol>
<li><strong><code>std::sync::Mutex&lt;T&gt;</code> (互斥锁)</strong>
<ul>
<li><strong>用途：</strong> 最常见的互斥锁，用于保护共享数据，确保一次只有一个线程可以访问该数据。</li>
<li><strong>特点：</strong>
<ul>
<li>当线程尝试获取已被锁定的 Mutex 时，它会阻塞直到锁被释放。</li>
<li>提供内部可变性（<code>&amp;T</code> -&gt; <code>&amp;mut T</code>）通过 RAII (Resource Acquisition Is Initialization) 机制，即 <code>MutexGuard</code>。当 <code>MutexGuard</code> 离开作用域时，锁会自动释放。</li>
<li>是“poisoning”感知的：如果持有锁的线程在锁被释放前发生 panic，<code>Mutex</code> 会被标记为 poisoned。后续尝试获取锁的线程会得到一个 <code>PoisonError</code>，其中包含原始的 <code>MutexGuard</code>，允许它们决定如何处理被中断的数据。</li>
</ul>
</li>
<li><strong>何时使用：</strong> 当你需要独占访问某个共享资源时，例如全局计数器、数据结构或配置设置。</li>
</ul>
</li>
<li><strong><code>std::sync::RwLock&lt;T&gt;</code> (读写锁)</strong>
<ul>
<li><strong>用途：</strong> 允许多个读取者同时访问共享数据，但只允许一个写入者独占访问数据。</li>
<li><strong>特点：</strong>
<ul>
<li><strong>读取者（<code>read()</code>）：</strong> 允许多个线程并行获取读锁。只要没有写入者持有锁，所有读锁请求都会成功。</li>
<li><strong>写入者（<code>write()</code>）：</strong> 只允许一个线程获取写锁。当有写入者持有锁时，所有读锁和写锁请求都会阻塞。</li>
<li>也提供 RAII 机制，通过 <code>RwLockReadGuard</code> 和 <code>RwLockWriteGuard</code>。</li>
<li>同样是“poisoning”感知的。</li>
</ul>
</li>
<li><strong>何时使用：</strong> 当你的数据被频繁读取但很少写入时，<code>RwLock</code> 可以提供比 <code>Mutex</code> 更好的并发性能。例如，一个缓存系统或一个配置对象。</li>
</ul>
</li>
<li><strong><code>std::sync::Once</code> (只运行一次)</strong>
<ul>
<li><strong>用途：</strong> 确保某个代码块（一个初始化函数）在程序生命周期中只被执行一次，即使有多个线程同时尝试触发它。</li>
<li><strong>特点：</strong>
<ul>
<li><code>call_once()</code> 方法会执行一个闭包。第一次调用会实际执行闭包，后续的调用会等待第一次调用完成，但不会再次执行闭包。</li>
<li>通常用于惰性初始化全局数据或单例模式。</li>
</ul>
</li>
<li><strong>何时使用：</strong> 初始化全局静态变量（例如日志系统、配置加载器）或实现单例模式。通常与 <code>lazy_static</code> crate (在稳定版 Rust 中) 或 <code>std::sync::OnceLock</code> (在 1.70+ 版本中，见下文) 结合使用。</li>
</ul>
</li>
<li><strong><code>std::sync::Barrier</code> (屏障)</strong>
<ul>
<li><strong>用途：</strong> 用于同步一组线程，确保所有线程都到达某个预定义点后才能继续执行。</li>
<li><strong>特点：</strong>
<ul>
<li>通过 <code>wait()</code> 方法实现等待。当调用 <code>wait()</code> 的线程数量达到预设值时，所有等待的线程都会同时被释放。</li>
<li><code>wait()</code> 返回一个 <code>BarrierWaitResult</code>，指示当前线程是否是最后一个到达屏障的。</li>
</ul>
</li>
<li><strong>何时使用：</strong> 需要协调多个并行任务的执行，例如在某个阶段结束后开始下一阶段，或者在所有子任务完成后进行汇总。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>Rust 1.70+ 中引入的更现代的基于锁的 API：</strong></p>
          
        </div>

        
          <div>
            <a class="read-more button inline" href="/posts/2025-08/kaist-cs431-lock-based-api/">[Read more]</a>
          </div>
        
      </article>
    
      <article class="post on-list">
        <h2 class="post-title">
          <a href="https://chengzhycn.github.io/posts/2025-08/wasm-internals-overview/">Wasm Internals - Overview</a>
        </h2>

        <div class="post-meta"><time class="post-date">2025-08-26</time></div>

        
          <span class="post-tags">
            
            #<a href="https://chengzhycn.github.io/tags/wasm/">Wasm</a>&nbsp;
            
          </span>
        

        


        <div class="post-content">
          
            <ul>
<li><a href="https://rsms.me/wasm-intro">https://rsms.me/wasm-intro</a></li>
<li><a href="https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/">https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/</a></li>
</ul>
<h2 id="wasm-的历史发展">Wasm 的历史发展</h2>
<h3 id="早期wasm-mvp---2017">早期（Wasm MVP - 2017）</h3>
<ul>
<li><strong>诞生背景：</strong> Wasm 的设计目标是为了替代 asm.js，提供更小、更快、更安全的 Web 二进制格式。</li>
<li><strong>核心模块的初步定义：</strong> MVP（Minimum Viable Product）阶段定义了 Wasm Core Module 的基本结构：函数、内存、表、导入、导出、全局变量等。</li>
<li><strong>主要用例：</strong> 游戏引擎、音视频编解码、计算密集型任务等。</li>
<li><strong>限制：</strong>
<ul>
<li><strong>没有模块化系统：</strong> 模块之间没有标准的链接机制，只能通过宿主环境（如 JavaScript）进行协调。</li>
<li><strong>缺乏垃圾回收（GC）：</strong> 需要手动内存管理或使用语言自带的 GC 机制（如 Emscripten 的 mimalloc）。</li>
<li><strong>没有线程：</strong> 无法直接利用多核 CPU。</li>
<li><strong>没有宿主 API 标准化：</strong> 模块与宿主环境的交互方式高度依赖宿主（如浏览器），没有统一的接口定义。</li>
<li><strong>没有组件模型：</strong> 模块重用和组合非常困难。</li>
</ul>
</li>
</ul>
<h3 id="中期mvp-之后---持续演进">中期（MVP 之后 - 持续演进）</h3>
<p>Wasm 社区和工作组认识到 MVP 的局限性，并开始着手扩展 Wasm 的能力，这直接影响了 Core Module 的能力：</p>
<ul>
<li><strong>多值（Multiple Returns &amp; Parameters）：</strong> 允许函数返回多个值，接收多个参数，提高表达能力。</li>
<li><strong>引用类型（Reference Types）：</strong> 引入了 <code>externref</code> 和 <code>funcref</code>，允许 Wasm 直接引用宿主对象和函数，而无需通过数字 ID 传递，为未来的 GC 和组件模型打下基础。</li>
<li><strong>固定大小的 SIMD（Fixed-width SIMD）：</strong> 引入了新的指令集，允许在 Wasm 中进行向量化操作，进一步提升某些计算密集型任务的性能。</li>
<li><strong>线程（Threads）：</strong> 引入了共享内存和原子操作，允许 Wasm 模块在多线程环境下运行，极大地提升了并行计算能力。</li>
<li><strong>内存增长和限制（Memory Growth and Limits）：</strong> 提供了更灵活的内存管理机制。</li>
<li><strong>Tail Calls（尾调用）：</strong> 优化了函数调用的性能。</li>
</ul>
<h3 id="近期和未来wasm-component-model">近期和未来（Wasm Component Model）</h3>
<p>这是 Wasm 发展中最重要的方向之一，旨在解决 Core Module 在模块化和互操作性方面的根本性问题：</p>
          
        </div>

        
          <div>
            <a class="read-more button inline" href="/posts/2025-08/wasm-internals-overview/">[Read more]</a>
          </div>
        
      </article>
    
      <article class="post on-list">
        <h2 class="post-title">
          <a href="https://chengzhycn.github.io/posts/2025-03/c-common-coding-conventions/">C³: Common Coding Conventions</a>
        </h2>

        <div class="post-meta"><time class="post-date">2025-03-29</time></div>

        

        


        <div class="post-content">
          
            <h1 id="c-common-coding-conventions">C³: Common Coding Conventions</h1>
<p><a href="https://google.github.io/eng-practices/">https://google.github.io/eng-practices/</a></p>
<p><a href="https://github.com/tum-esi/common-coding-conventions">https://github.com/tum-esi/common-coding-conventions</a></p>
<p>The goal of these conventions is to be concise, universal, and remarkable. It targets emerging code enthusiasts under time pressure and covers 7 topics:</p>
<ol>
<li><a href="/posts/2025-03/c-common-coding-conventions/#user-content-general-clarifications">General Clarifications</a>,</li>
<li><a href="/posts/2025-03/c-common-coding-conventions/#user-content-architecture">Architecture</a>,</li>
<li><a href="/posts/2025-03/c-common-coding-conventions/#user-content-implementation">Implementation</a>,</li>
<li><a href="/posts/2025-03/c-common-coding-conventions/#user-content-naming">Naming</a>,</li>
<li><a href="/posts/2025-03/c-common-coding-conventions/#user-content-code-layout">Code Layout</a>,</li>
<li><a href="/posts/2025-03/c-common-coding-conventions/#user-content-documentation">Documentation</a>, and</li>
<li><a href="/posts/2025-03/c-common-coding-conventions/#user-content-languages">Languages</a>.</li>
</ol>
<p>To follow this guide, you should already have heard about <a href="https://www.educative.io/blog/object-oriented-programming">Object Oriented Programming</a> and know basic programming rules, such as writing loops and meaningful functions instead of copy pasting
instructions. In this Readme, we will shortly summarize the most important rules for every topic.</p>
          
        </div>

        
          <div>
            <a class="read-more button inline" href="/posts/2025-03/c-common-coding-conventions/">[Read more]</a>
          </div>
        
      </article>
    

    <div class="pagination">
  <div class="pagination__buttons">
    
    
    
      <a href="/page/2/" class="button inline next">
        [<span class="button__text">Older posts</span>] &gt;
      </a>
    
  </div>
</div>

  </div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
